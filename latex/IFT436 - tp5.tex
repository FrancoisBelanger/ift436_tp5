\documentclass[11pt]{article} % A4 paper and 11pt font size

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[french]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{fullpage}

\usepackage{algpseudocode}
\usepackage{listings}

\usepackage{enumitem}
\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\renewcommand{\theenumi}{\alph{enumi}}
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text
\title{IFT436 - Algorithmes et structures de données}
\author{François Bélanger 94 245 437, Jérémie Coulombe 13 061 991 et Geneviève Dostie 12 078 306}

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
\normalfont \normalsize 
\textsc{Universite de Sherbrooke} \\ [25pt] % Your university, school and/or department name(s)
\horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
\huge Devoir \#5 \\ % The assignment title
\horrule{2pt} \\[0.5cm] % Thick bottom horizontal rule
}

\author{François Bélanger, Jérémie Coulombe et Geneviève Dostie} % Your name

\date{\normalsize\today} % Today's date or a custom date

\begin{document}
\input{./title_page.tex}

%----------------------------------------------------------------------------------------
%	Introduction
%----------------------------------------------------------------------------------------
\textbf{Introduction}\\
Pour ce dernier travail pratique du cours, il était question d'effectuer une étude de performance de différents algorithmes s'attaquant au même problème. Les équipes étaient libres de choisir un problème de leur choix et de réunir un minimum de trois algorithmes différents pour résoudre celui-ci. Dans le cas présent, le calcul de l'arbre sous-tendant de coût minimal d'un graphe non-orienté connexe valué à été sélectionné. Trois algorithmes classiques -- ceux de Bor\r{u}vka, de  Krustal et de Prim -- ont été retenu pour l'étude. Ceux-ci ont été codés et exécutés avec Python.

\vspace{0.3cm}

Dans ce rapport seront présenté les algorithmes choisis, incluant les hypothèses concernant leur complexité, les outils de travail utilisés, tant pour partager les sources que pour les développer, la conception du générateur d'échantillons aléatoires ainsi que les résultats de l'étude.

\vspace{0.7cm}

%----------------------------------------------------------------------------------------
%	Outil de travail
%----------------------------------------------------------------------------------------
\textbf{Outil de travail}\\
Pour ce travail, le langage choisi a été Python, sous sa version 2.7. Bien qu'il ne figure pas dans les palmarès des langages les plus performants, l'expérience a été tentée, permettant ainsi pour la plupart des coéquipiers d'en apprendre davantage sur ce langage . De plus, il semblait plus simple  -- du moins, c'est ce qui était prévu!  -- de trouver de bons algorithmes sur internet afin de se concentrer plus sur les tests et les résultats. Hélas, la réécriture de 2 des 3 algorithmes a été nécessaire.
\vspace{0.3cm}

Pour programmer en Python, l'environnement de développement choisi a été PyCharm 4.5.3. Dans PyCharm est inclus un outil Git qui a été utile pour le travail; en effet, le client web GitHub fut utilisé pour le partage des sources, la distribution de tâches et pour la consultation de l'historique des changements pour les cas de nécessité de retour en arrière.

\vspace{0.7cm}

%----------------------------------------------------------------------------------------
%	Nos algorithmes
%----------------------------------------------------------------------------------------
\textbf{Nos algorithmes}\\
Le choix des algorithmes a été orienté par la liste des algorithmes de calcul de l'arbre sous-tendant à coût minimal présentée en classe, ainsi que par un 3e algorithme inclus dans la liste des propositions dans l'énoncé du travail. Les algorithmes développés par Bor\r{u}vka,  Krustal et Prim sont tous de stratégie gloutonne, mais ne partagent pas les mêmes complexités algorithmiques.

\vspace{0.3cm}

L'algorithme de Bor\r{u}vka n'a pas été trouvé sur internet en langage Python, donc une version dérivée du pseudo-code présenté sur la page Wikipédia << Bor\r{u}vka algorithm >> a été programmée. L'algorithme de Kruskal a été tiré et adapté d'un dépôt GitHub de l'utilisateur << israelst >>, qui indique l'avoir adapté du livre << Algorithms >> de Dasgupta, Papadimitriou et Vazurani. Aucun algorithme efficace n'ayant été trouvé pour la méthode de Prim, une adaptation Python du pseudo-code présenté dans les notes du présent cours a été préconisée. Une classe représentant un ensemble d'ensembles disjoints a été créée pour unifier le fonctionnement des algorithmes de Bor\r{u}vka et de Krustal. Le code a été tiré des sources originales de l'algorithme de Kruskal trouvé sur internet. 

\vspace{0.3cm}

\underline{Hypothèses}\\
Tout d'abord, la complexité des algorithmes devrait être les suivantes pour un $m$ signifiant le nombre d'arêtes du graphe et $n$ son nombre de noeuds: $O(m\, log\, n)$ pour Bor\r{u}vka, $O(m\, log\, m)$ pour Kruskal et $O(m\, log\, n)$ pour Prim.
Il est donc à comprendre qu'étant de même complexité, Bor\r{u}vka et Prim auront un temps d'exécution similaire. Pour ce qui est de Kruskal, il devrait être le moins performant des trois algorithmes, car son $log$ s'applique sur le nombre d'arêtes de non sur le nombre de noeuds.

\vspace{0.7cm}

%----------------------------------------------------------------------------------------
%	Générateur de graphe
%----------------------------------------------------------------------------------------

\textbf{Générateur d'échantillons}\\
La dernière affirmation est vraie, car le générateur utilisé pour générer les données de l'étude a été paramétré pour générer des graphes ayant exactement 10 fois plus d'arêtes que de noeuds. Il fonctionne de la façon suivante: on relie $n$ noeuds de façon linéaire par des arêtes de poids aléatoires entre 1 et 100 puis on génère des arêtes de même distribution de poids entre des paires noeuds non-reliés choisis aléatoirement jusqu'à atteindre un nombre d'arêtes égales à 10 fois le nombre de noeuds.

\vspace{0.3cm}

\underline{Générateur de nombres aléatoires}\\
Le générateur de nombres aléatoires générique de Python est basé sur une implémentation en C du \textit{Marsenne Twister} \footnote{https://en.wikipedia.org/wiki/Mersenne\_Twister}, un algorithme avec une période de $2^{19937}-1$ fortement testé. Dans le code du générateur de graphe, la fonction \textit{randint} de Python est utilisée, qui est une application du \textit{random} de Python qui utilise le \textit{Marsenne Twister}.

\vspace{0.7cm}

%----------------------------------------------------------------------------------------
%	Résultats
%----------------------------------------------------------------------------------------

\textbf{Méthodologie}\\
À COMPLÉTER\\
\vspace{0.3cm}

Pour recueillir les données sur le temps d'exécution versus le nombre de sommets, la librairie \textit{matplotlib} a été importée. Cette librairie permet de tracer un graphique à partir des données recueillies, évitant ainsi la nécessité d'une compilation des résultats bruts dans un fichier pour ensuite produire des graphiques avec un logiciel comme Excel.

\vspace{0.5cm}

\underline{Résultats}\\

\vspace{0.7cm}

%----------------------------------------------------------------------------------------
%	Conclusion
%----------------------------------------------------------------------------------------
\textbf{Conclusion}\\
En conclusion,


\vspace{0.7cm}

%----------------------------------------------------------------------------------------
%	Annexe
%----------------------------------------------------------------------------------------
\newpage
\begin{center} \Large\textbf{Annexes} \end{center}
\textbf{boruvka.py}
\lstinputlisting[language=Python, basicstyle=\scriptsize]{../src/boruvka.py}
\vspace{0.5cm}

\textbf{kruskal.py}
\lstinputlisting[language=Python, basicstyle=\scriptsize]{../src/kruskal.py}
\vspace{0.5cm}

\textbf{prim.py}
\lstinputlisting[language=Python, basicstyle=\scriptsize]{../src/prim.py}
\vspace{0.5cm}

\textbf{graph\_generator.py}
\lstinputlisting[language=Python, basicstyle=\scriptsize]{../src/graph_generator.py}
\vspace{0.5cm}

\textbf{disjoint\_set}
\lstinputlisting[language=Python, basicstyle=\scriptsize]{../src/disjoint_set.py}
\vspace{0.5cm}

\textbf{framework.py}
\lstinputlisting[language=Python, basicstyle=\scriptsize]{../src/framework.py}
\end{document}
