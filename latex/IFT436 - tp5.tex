\documentclass[11pt]{article} % A4 paper and 11pt font size

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[french]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{fullpage}

\usepackage{algpseudocode}

\usepackage{enumitem}
\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\renewcommand{\theenumi}{\alph{enumi}}
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text
\title{IFT436 - Algorithmes et structures de données}
\author{François Bélanger 94 245 437, Jérémie Coulombe 13 061 991 et Geneviève Dostie 12 078 306 et }

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
\normalfont \normalsize 
\textsc{Universite de Sherbrooke} \\ [25pt] % Your university, school and/or department name(s)
\horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
\huge Devoir \#5 \\ % The assignment title
\horrule{2pt} \\[0.5cm] % Thick bottom horizontal rule
}

\author{François Bélanger, Jérémie Coulombe et Geneviève Dostie} % Your name

\date{\normalsize\today} % Today's date or a custom date

\begin{document}
\input{./title_page.tex}

%----------------------------------------------------------------------------------------
%	Introduction
%----------------------------------------------------------------------------------------
\Large\textbf{Introduction}\\
Dans le cadre du dernier travail, une étude de performance d'exécution de différents algorithmes pour un même type de problème était à faire. Chaque équipe devait choisir un problème et au moins trois algorithmes pour résoudre le problème choisi. L'équipe a choisi le problème du calcul de l'arbre sous-tendant de coût minimal. Les trois algorithmes sont : Bor\r{u}vska, Krustal et Prim. Les trois algorithmes ont été codé en Python avec le logiciel PyCharm.
\vspace{0.3cm}

Dans ce rapport, il sera présenté les outils de travail pour partager le code et facilité l'avancement du travail, les algorithmes choisis, la conception du générateur d'échantillon pour faire les test et les résultats de no tests avec les hypothèses les algorithmes.
\vspace{0.7cm}

%----------------------------------------------------------------------------------------
%	Outil de travail
%----------------------------------------------------------------------------------------
\Large\textbf{Outil de travail}\\
Pour ce travail, le langage choisit est le Python, version 2.7 . C'était un langage que certain connaissait plus que d'autre, mais simple et rapide à comprendre. De plus, il semblait plus simple de trouver les algorithmes choisis codés afin de ce concentrer plus sur les tests et les résultats.
\vspace{0.3cm}

Pour programmer en Python, le programme de programmation choisit est PyCharm. PyCharm donne accès à un outil Git pratique et facile à utiliser contrairement à d'autre programme comme Visual Studio pour C++. GitHub fut utilisé avant tout pour le partage et faciliter l'accès au code, la distribution de tâches et permettre de garder les un historique des changement au cas où il faudrait revenir en arrière.
\vspace{0.7cm}

%----------------------------------------------------------------------------------------
%	Nos algorithmes
%----------------------------------------------------------------------------------------
\Large\textbf{Nos algorithmes}\\
Le choix des algorithmes fut en fonction de ce qui a été vu en classe et des algorithmes proposés dans l'énoncé du travail. Les algorithmes choisis pour ce travail sont Bor\r{u}vska, Krustal et Prim. Ce sont trois algorithmes de stratégie gloutonne, mais avec des complexités différentes que nous présenterons dans nos hypothèses.
\vspace{0.3cm}

Le seul algorithme dont le code a été trouvé sur Internet, c'est celui de  Kruskal. Quant à Bor\r{u}vka et Prim, aucun code acceptable a été trouvé, donc c'était préférable de les écrire pour ne pas perdre trop de temps sur cet tâche. Dans ce cas-ci, un code raisonnable a été déterminé par le fait qu'il ne demande pas de modification majeur et qu'il est construit de manière optimal.
\vspace{0.5cm}

\underline{Classe DisjointSet}\\
La classe DisjointSet a été créé pour les algoritmes Bor\r{u}vska et Krustal, qui est tiré du code de l'algorithme de Kruskal. Celui-ci permet de faire des ensembles de sommets, trouver un sommet et relier 2 sommets ensembles. Cette partie de code était avant tout utilisée pour l'algorithme de Kruskal. Celle-ci a été mise dans une classe pour avoir la possibilité, lorsque possible, de l'utiliser dans d'autre algorithme.
\vspace{0.7cm}

%----------------------------------------------------------------------------------------
%	Générateur de graphe
%----------------------------------------------------------------------------------------
\Large\textbf{Générateur d'échantillon}\\
Le générateur de graphe a été construit selon la documentation trouvé sur Internet: \textit{https://en.wikipedia.org/wiki/Mersenne\_Twister}. Dans le code du générateur de graphe, la fonction << \textit{random} >> de Python est utilisée. Contrairement à la fonction de C++, celui-ci est efficace.

\vspace{0.7cm}

%----------------------------------------------------------------------------------------
%	Résultats
%----------------------------------------------------------------------------------------
\Large\textbf{Expérience de travail}\\
Il sera présenté dans cette section les hypothèses puis les résultats de des tests. Il sera expliqué la méthodologie pour obtenir les résultats. Il sera considérer $n$ le nombre de sommets et $m$ le nombre d'arêtes.
\vspace{0.5cm}

\underline{Hypothèses}\\
D'abord, la complexité des algorithme devraientt être: $O(m\, log\, n)$ pour Bor\r{u}vka, $O(m\, log\, m)$ pour Kruskal et $O(m\, log\, n)$ pour Prim.
Il est à croire qu'étant de même complexité, Bor\r{u}vka et Prim auront un temps de calcul similaire. Pour ce qui est de Kruskal, il devrait être le plus performant des trois algorithmes par sa différence $log\, m$, car il y aura au plus $\frac{n(n-1)}{2}$ arêtes.
\vspace{0.5cm}

\underline{Méthodologie}\\
Pour faire le temps de calcul pour un graphe de $n$ sommets, une moyenne du temps est fait sur une boucle qui exécute 100 fois sur une même taille d'échantillon. Pour ce qui est de l'échantillonnage, il est fait par pas de $10^i$, pour $i$ = 1, 2, ..., $k$. Le k est déterminé selon la rapidité d'exécution de l'ordinateur, choisit dans le laboratoire informatique.\\
\vspace{0.3cm}

Pour recueillir les données sur le temps d'exécution versus le nombre de sommet, un << package >> a été importé.
\vspace{0.5cm}

\underline{Résultats}\\

\vspace{0.7cm}

%----------------------------------------------------------------------------------------
%	Conclusion
%----------------------------------------------------------------------------------------
\Large\textbf{Conclusion}\\
En conclusion,

\end{document}
